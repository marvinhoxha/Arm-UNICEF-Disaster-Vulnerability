import os
import cv2
import pandas as pd
import ast
import numpy as np
from tqdm import tqdm

def rotate_image_and_bbox(image, bbox, angle):
    (h, w) = image.shape[:2]
    (cx, cy) = (w // 2, h // 2)

    # Rotate the image
    M = cv2.getRotationMatrix2D((cx, cy), angle, 1.0)
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    
    # Compute the new bounding dimensions of the image
    nW = int((h * sin) + (w * cos))
    nH = int((h * cos) + (w * sin))
    
    # Adjust the rotation matrix to take into account translation
    M[0, 2] += (nW / 2) - cx
    M[1, 2] += (nH / 2) - cy
    
    rotated_image = cv2.warpAffine(image, M, (nW, nH))
    
    # Rotate bounding box
    x, y, w, h = bbox
    points = np.array([[x, y], [x + w, y], [x, y + h], [x + w, y + h]])
    ones = np.ones(shape=(len(points), 1))
    points_ones = np.hstack([points, ones])
    
    transformed_points = M.dot(points_ones.T).T
    min_x = min(transformed_points[:, 0])
    min_y = min(transformed_points[:, 1])
    max_x = max(transformed_points[:, 0])
    max_y = max(transformed_points[:, 1])
    
    new_bbox = [min_x, min_y, max_x - min_x, max_y - min_y]
    
    return rotated_image, new_bbox

def augment_and_save_images(image_dir, output_dir, annotations_file, output_annotations_file, angle=90):
    # Load the annotations
    annotations = pd.read_csv(annotations_file)
    
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Initialize a list to store the updated annotations
    augmented_annotations = []
    
    # Iterate through the dataset with a progress bar
    for index, row in tqdm(annotations.iterrows(), total=annotations.shape[0]):
        image_id = row['image_id']
        bbox_str = row['bbox']
        
        if pd.isna(bbox_str):
            continue
        
        bbox = ast.literal_eval(bbox_str)  # Convert the string representation of the list to an actual list
        
        # Load the image
        img_path = os.path.join(image_dir, f"{image_id}.tif")  # Assuming images are in .tif format
        if not os.path.exists(img_path):
            continue
        img = cv2.imread(img_path)
        
        # Rotate the image and bounding box
        rotated_img, new_bbox = rotate_image_and_bbox(img, bbox, angle)
        
        # Save the rotated image
        rotated_image_id = f"{image_id}_rot{angle}"
        rotated_img_path = os.path.join(output_dir, f"{rotated_image_id}.tif")
        cv2.imwrite(rotated_img_path, rotated_img)
        
        # Update the annotations
        augmented_annotations.append({
            'image_id': rotated_image_id,
            'bbox': new_bbox,
            'category_id': row['category_id'],
            'id': row['id']
        })
    
    # Save the updated annotations to a new CSV file
    augmented_annotations_df = pd.DataFrame(augmented_annotations)
    augmented_annotations_df.to_csv(output_annotations_file, index=False)

# Define the paths
image_dir = 'Resized_Images'  # Path to the directory containing images
output_dir = 'Resized_Images'  # Path to the directory to save augmented images
annotations_file = 'Data/Resized_Train.csv'  # Path to the annotations file
output_annotations_file = 'Data/Augmented_Train.csv'  # Path to save updated annotations

# Augment images and update annotations
# augment_and_save_images(image_dir, output_dir, annotations_file, output_annotations_file, angle=90)
augment_and_save_images(image_dir, output_dir, annotations_file, "Data/Augmented_Train180.csv", angle=180)
augment_and_save_images(image_dir, output_dir, annotations_file, "Data/Augmented_Train270.csv", angle=270)
