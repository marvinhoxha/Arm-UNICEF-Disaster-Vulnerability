import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt
from PIL import Image
import re
import matplotlib.patches as patches
from ultralytics import YOLO
import os
import yaml
import json
from tqdm import tqdm
import mlflow
from ultralytics import settings
import torch

# Update a setting
settings.update({"mlflow": True})

# Hyperparameters
EPOCHS = 200
BATCH_SIZE = 32
OPTIMIZER = "auto"
SEED = 42
NAME = f"Arm_Yolo_{EPOCHS}"
DEVICE = [0]
VERBOSE = False
RESUME = False
PATIENCE = 20
img_height = 512
img_width = 512

# Model weights for ensembling
model_weights = [0.3,0.2,0.2,0.2,0.1]

# Custom confidence thresholds for different classes for each model
custom_conf_thresholds_list = [
    {0: 0.8, 1: 0.6, 2: 0.6}, 
    {0: 0.5, 1: 0.7, 2: 0.5},
    {0: 0.5, 1: 0.7, 2: 0.5},
    {0: 0.5, 1: 0.7, 2: 0.5},
    {0: 0.5, 1: 0.7, 2: 0.5}  
]

def get_classes_count(pred_json: str):
    classes_count = {0: 0, 1: 0, 2: 0}
    for j in json.loads(pred_json):
        classes_count[j['class']] += 1
    return classes_count   

def filter_results(results, conf_thresholds):
    filtered_boxes = []
    for box in results[0].boxes:
        class_id = int(box.cls)
        if box.conf >= conf_thresholds[class_id]:  # Use the specific threshold for each class
            filtered_boxes.append(box)
    return filtered_boxes

def weighted_average_ensembled_predictions(preds_list, model_weights, conf_thresholds_list):
    weighted_counts = {0: 0.0, 1: 0.0, 2: 0.0}
    for pred, weight, conf_thresholds in zip(preds_list, model_weights, conf_thresholds_list):
        filtered_boxes = filter_results(pred, conf_thresholds)
        class_counts = get_classes_count(json.dumps([{"class": int(box.cls), "conf": float(box.conf)} for box in filtered_boxes]))
        for cls in class_counts:
            weighted_counts[cls] += class_counts[cls] * weight
    
    return weighted_counts

def generate_submission_file(test, models, model_weights, conf_thresholds_list, submission_file):
    submission_df = pd.DataFrame(columns=["image_id", "Target"])
    for index, row in tqdm(test.iterrows(), total=len(test)):
        preds_list = []
        for model in models:
            pred = model.predict(f"Images/{row['image_id']}.tif", iou=0.6, conf=0.1, save_txt=True, save_conf=True, agnostic_nms=True)
            preds_list.append(pred)
        
        weighted_counts = weighted_average_ensembled_predictions(preds_list, model_weights, conf_thresholds_list)
        
        df = pd.DataFrame({
            "image_id": [f"{row['image_id']}_1", f"{row['image_id']}_2", f"{row['image_id']}_3"],
            "Target": [weighted_counts[0], weighted_counts[1], weighted_counts[2]]
        }, columns=["image_id", "Target"])
        
        submission_df = pd.concat([submission_df, df], axis=0)
    
    submission_df.to_csv(submission_file, index=False)
        
def train():
    test = pd.read_csv("Data/Test.csv")
    torch.cuda.empty_cache()
    
    # Load multiple models
    models = [YOLO('200epochs.pt'), YOLO('last500model.pt'), YOLO('elvjo400.pt'),YOLO('yolo9_512model.pt'),YOLO('1024model.pt')]  
    
    sub_file = 'subbmission_files/ensemble7_5models.csv'
    generate_submission_file(test, models, model_weights, custom_conf_thresholds_list, sub_file)

if __name__ == "__main__":
    train()
